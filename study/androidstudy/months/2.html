<!DOCTYPE html>
<html>
	<head>
       		<meta charset="utf-8">
        	<meta http-equiv="X-UA-Compatible" content="IE=edge">
        	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        	<meta name="apple-mobile-web-app-capable" content="yes">
        	<meta name="apple-mobile-web-app-status-bar-style" content="black">
        	<meta name="mobile-web-app-capable" content="yes">
		<link rel="stylesheet" href="../css/style.css">
	</head>
	<body>
		<h3>1주</h3>
			<ul>
				<li>월</li>
				<ol>
					<li>Thread란?
<code class="text">
== Multi-tasking ==
여러 개의 애플리케이션을 동시에 실행하여서 컴퓨터 시스템의 성능을 높이기 위한 기법
</code>
					</li>
					<li>Thread 사용방법 2가지
<code clas="text">
1. Thread 클래스를 상속하는 방법
Thread 클래스를 extends한 후 run()에 Thread가 할 일(명세서)을 정의.

2. Runnable 인터페이스를 구현하는 방법
Runnable 인터페이스를 implements한 후 run()에 할 일을 작성.
----------------------------------------------------------------
Thread 객체를 생성할 때 Thread가 동작해야할 객체를 생성자의 인자로 넣는다.
start()로 Thread시작한다.
</code>
					</li>
					<li>Thread 사용시 문제점!!! -> synchronized로 해결
<code class="java">
package test05;

public class BankAccount {
	private int balance;

	public void deposit(int money) {
		balance += money;
		if(balance<0) {
			System.out.println("잔액 마이너스!!?: "+balance);
		}
	}

	public void withdraw(int money) {
		balance -= money;
		if(balance<0) {
			System.out.println("잔액 마이너스!!?: "+balance);
		}
	}
}
</code>
<br>
<code>
package test05;

public class MoneyThread extends Thread{
	private BankAccount account;

	public MoneyThread(BankAccount account) {
		this.account = account;
	}

	@Override
	public void run() {
		for(int i = 0 ; i < 10000000 ; i++) {
			account.deposit(1000);

			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			account.withdraw(1000);
		}
	}
}
</code>
<br>
<code class="java">
package test05;

public class Test {
	public static void main(String[] args) {
		BankAccount a = new BankAccount();

		MoneyThread t1 = new MoneyThread(a);
		MoneyThread t2 = new MoneyThread(a);

		t1.start();
		t2.start();
	}
}
</code>
<br>
<code class="text">
위의 문제점은 음수가 출력될 수도 있다는 것이다.
왜냐하면 t1 혹은 t2가 처리 중에 t2 혹은 t1가 작업을 할 수 있기 때문이다.
이러기 위해서 다른 하나가 처리중이라면 또 다른 하나는 접근할 수 없게 해야한다.
이때 사용하는 것이 synchronized이다.
</code>
<br>
<code class="java">
package test05;

public class BankAccount {
	private int balance;

	public synchronized void deposit(int money) {
		balance += money;
		if(balance'<'0) {
			System.out.println("잔액 마이너스!!?: "+balance);
		}
	}

	public synchronized void withdraw(int money) {
		balance -= money;
		if(balance'<'0) {
			System.out.println("잔액 마이너스!!?: "+balance);
		}
	}
}
</code>
					</li>
				</ol>
				<li>화</li>
				<ol>
					<li>무진행</li>
				</ol>
				<li>수</li>
				<ol>
					<li>무진행</li>
				</ol>
				<li>목</li>
				<ol>
					<li>무진행</li>
				</ol>
				<li>금</li>
				<ol>
					<li>무진행</li>
				</ol>
			</ul>
		<h3>2주</h3>
				<ul>
					<li>월</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>화</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>수</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>목</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>금</li>
					<ol>
						<li>무진행</li>
					</ol>
				</ul>

		<h3>3주</h3>
				<ul>
					<li>월</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>화</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>수</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>목</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>금</li>
					<ol>
						<li>무진행</li>
					</ol>
				</ul>
			<h3>4주</h3>
				<ul>
					<li>월</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>화</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>수</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>목</li>
					<ol>
						<li>무진행</li>
					</ol>
					<li>금</li>
					<ol>
						<li>무진행</li>
					</ol>
				</ul>
	</body>
<html>
